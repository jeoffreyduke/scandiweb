{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isNode, QueryDocumentKeys } from './ast.mjs';\nimport { Kind } from './kinds.mjs';\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport const BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\n\nexport function visit(root, visitor) {\n  let visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n  const enterLeaveMap = new Map();\n\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));\n\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      path.push(key);\n    }\n\n    let result;\n\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;\n      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n\n  return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const {\n        enter,\n        leave\n      } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave = {\n      enter() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n\n            const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n\n      leave() {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n\n            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      }\n\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\n\nexport function getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined\n    };\n  } // { enter() {}, leave() {} }\n\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\n\n/* c8 ignore next 8 */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  const {\n    enter,\n    leave\n  } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}","map":{"version":3,"sources":["/home/duke/Code/scandiweb/node_modules/graphql/language/visitor.mjs"],"names":["devAssert","inspect","isNode","QueryDocumentKeys","Kind","BREAK","Object","freeze","visit","root","visitor","visitorKeys","enterLeaveMap","Map","kind","values","set","getEnterLeaveForKind","stack","undefined","inArray","Array","isArray","keys","index","edits","node","key","parent","path","ancestors","isLeaving","length","isEdited","pop","slice","editOffset","editKey","editValue","arrayKey","splice","defineProperties","getOwnPropertyDescriptors","prev","push","result","_enterLeaveMap$get","_enterLeaveMap$get2","visitFn","get","leave","enter","call","_node$kind","visitInParallel","visitors","skipping","fill","mergedVisitor","create","hasVisitor","enterList","leaveList","i","mergedEnterLeave","args","_enterList$i","apply","_leaveList$i","kindVisitor","getVisitFn"],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isNode, QueryDocumentKeys } from './ast.mjs';\nimport { Kind } from './kinds.mjs';\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport const BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\n\nexport function visit(root, visitor, visitorKeys = QueryDocumentKeys) {\n  const enterLeaveMap = new Map();\n\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n  /* eslint-disable no-undef-init */\n\n  let stack = undefined;\n  let inArray = Array.isArray(root);\n  let keys = [root];\n  let index = -1;\n  let edits = [];\n  let node = root;\n  let key = undefined;\n  let parent = undefined;\n  const path = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n          let editOffset = 0;\n\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties(\n            {},\n            Object.getOwnPropertyDescriptors(node),\n          );\n\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      path.push(key);\n    }\n\n    let result;\n\n    if (!Array.isArray(node)) {\n      var _enterLeaveMap$get, _enterLeaveMap$get2;\n\n      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);\n      const visitFn = isLeaving\n        ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get === void 0\n          ? void 0\n          : _enterLeaveMap$get.leave\n        : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null ||\n          _enterLeaveMap$get2 === void 0\n        ? void 0\n        : _enterLeaveMap$get2.enter;\n      result =\n        visitFn === null || visitFn === void 0\n          ? void 0\n          : visitFn.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _node$kind;\n\n      stack = {\n        inArray,\n        index,\n        keys,\n        edits,\n        prev: stack,\n      };\n      inArray = Array.isArray(node);\n      keys = inArray\n        ? node\n        : (_node$kind = visitorKeys[node.kind]) !== null &&\n          _node$kind !== void 0\n        ? _node$kind\n        : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits[edits.length - 1][1];\n  }\n\n  return root;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor || (hasVisitor = enter != null || leave != null);\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave = {\n      enter(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _enterList$i;\n\n            const result =\n              (_enterList$i = enterList[i]) === null || _enterList$i === void 0\n                ? void 0\n                : _enterList$i.apply(visitors[i], args);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n\n      leave(...args) {\n        const node = args[0];\n\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            var _leaveList$i;\n\n            const result =\n              (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0\n                ? void 0\n                : _leaveList$i.apply(visitors[i], args);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      },\n    };\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\n\nexport function getEnterLeaveForKind(visitor, kind) {\n  const kindVisitor = visitor[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return {\n      enter: kindVisitor,\n      leave: undefined,\n    };\n  } // { enter() {}, leave() {} }\n\n  return {\n    enter: visitor.enter,\n    leave: visitor.leave,\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n *\n * @deprecated Please use `getEnterLeaveForKind` instead. Will be removed in v17\n */\n\n/* c8 ignore next 8 */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  const { enter, leave } = getEnterLeaveForKind(visitor, kind);\n  return isLeaving ? leave : enter;\n}\n"]},"metadata":{},"sourceType":"module"}