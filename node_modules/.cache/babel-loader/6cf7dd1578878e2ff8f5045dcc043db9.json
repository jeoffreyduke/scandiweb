{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport { assertInterfaceType, assertNullableType, assertObjectType, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isInputType, isOutputType } from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(false, `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(introspection)}.`); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(schemaIntrospection.types, typeIntrospection => typeIntrospection.name, typeIntrospection => buildType(typeIntrospection)); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection)\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection)\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType)\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, valueIntrospection => valueIntrospection.name, valueIntrospection => ({\n        description: valueIntrospection.description,\n        deprecationReason: valueIntrospection.deprecationReason\n      }))\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(`Introspection result missing fields: ${inspect(typeIntrospection)}.`);\n    }\n\n    return keyValMap(typeIntrospection.fields, fieldIntrospection => fieldIntrospection.name, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, inputValue => inputValue.name, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);\n    }\n\n    const defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"sources":["/home/duke/Code/scandiweb/node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["devAssert","inspect","isObjectLike","keyValMap","parseValue","assertInterfaceType","assertNullableType","assertObjectType","GraphQLEnumType","GraphQLInputObjectType","GraphQLInterfaceType","GraphQLList","GraphQLNonNull","GraphQLObjectType","GraphQLScalarType","GraphQLUnionType","isInputType","isOutputType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","GraphQLSchema","valueFromAST","buildClientSchema","introspection","options","__schema","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","Object","values","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","isRepeatable","slice"],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}